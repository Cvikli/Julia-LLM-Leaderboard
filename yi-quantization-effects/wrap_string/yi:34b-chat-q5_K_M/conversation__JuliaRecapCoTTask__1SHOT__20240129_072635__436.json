[{"content":"You are a world-class Julia language programmer and have a very systematic approach to solving problems.\n\nProblem Solving Steps:\n- Recall Julia snippets that will be useful for this Task\n- Solve the Task\n- Double-check that the solution is correct\n\nReminder on Julia Language:\n- Key Syntax: variables `x = 10`, control structures `if-elseif-else`, `isX ? X : Y`, `for`, `while`; functions `function f(x) end`, anonymous `x -> x^2`, arrays `[1, 2, 3]`, slicing `a[1:2]`, tuples `(1, 2)`, namedtuples `(; name=\"Julia\", )`, dictionary `Dict(\"key\" => value)`, `$` for string interpolation. \n- Prefer Julia standard libraries, avoid new packages unless explicitly requested. \n- Use general type annotations like `Number` or `AbstractString` to not be too restrictive. Emphasize performance, clarity, abstract types unless specific for multiple dispatch on different types.\n- Reserved names: `begin`, `end`, `function`. \n- Distinguished from Python with 1-based indexing, multiple dispatch\n\nIf the user provides any Special Instructions, prioritize them over the above guidelines.\n  ","variables":[],"_type":"systemmessage"},{"content":"# Task\n\nWrite a function `wrap_string`. It iterates over words and it will add a new line each time a maximum `text_width::Int=10` would be exceeded. Provide an example\n\n\n\n# Special Instructions\n\n{{instructions}}\n","variables":["task","instructions"],"_type":"usermessage"},{"content":"```julia\nfunction wrap_string(text::AbstractString, text_width::Int = 10)\n    lines = split(text, \" \") # Split the text into a list of words\n    line_lengths = map(length, lines) # Calculate the length of each word\n    wrapped_lines = Vector{String}() # Initialize an empty vector to store wrapped lines\n\n    current_line = \"\" # Start with an empty line\n    for (index, word) in enumerate(lines) # Iterate over words\n        if current_line * \" \" * word |> length > text_width # Check if the current line + word exceeds the text width\n            push!(wrapped_lines, current_line) # If yes, add the current line to the result and start a new one\n            current_line = word # The next word becomes the first of the new line\n        else\n            current_line *= \" \" * word # Append the word to the current line\n        end\n    end\n    push!(wrapped_lines, current_line) # Add the last line (if any) to the result\n\n    return wrapped_lines |> join # Join all lines with newline characters\nend\n\n# Example\ntext = \"Hello world. This is a very long sentence that should be wrapped at 10 characters per line.\"\nwrapped_text = wrap_string(text)\nprintln(wrapped_text)\n```\n\nThis function splits the text into words, calculates the length of each word, and then iterates over the words, adding a new line to the result when the current line plus the next word exceeds the specified `text_width`. It does this by keeping track of the \"current line\" which is initially empty and appending words to it until it becomes too long, at which point it is added to the result and the process starts again for the next word. Finally, the resulting vector of lines is joined back together with newline characters between each line.","status":200,"tokens":[0,439],"elapsed":14.527602504,"_type":"aimessage"}]