[{"content":"Act as a helpful AI assistant","variables":[],"_type":"systemmessage"},{"content":"Given a struct `FloatWithUnits` with fields `value` and `unit` (make sure to define it!), write a `show` method for it that will concatenate the value and unit with a space like this \"1.8 meters\".","variables":[],"_type":"usermessage"},{"content":"# Structs and Tuples\n## Motivation for Using Structs\n\nSo far, we've been using tuples to store data.\nTuples are very handy for storing simple pieces of related information together in a structured way.\nBut they can become unwieldy as the number of elements grows.\nThe same is true for `enum`s; they have their uses but for more complex data, we want something that's a bit more flexible.\n\n`struct`s are an alternative to tuples and `enum`s.\nStructs allow us to combine simple fields into a single entity and give these fields a name that makes sense in context.\nFor instance, instead of using a tuple to represent the position of something, we might define a struct like so:\n\n```rust,editable\nstruct Position(i32, i32);\n\n// This function takes a `Position` as an argument and returns nothing (it's type is `(Position) -> ()`).\nfn print_position(p: &Position) {\n    // Print the position to the console.\n}\n```\n\nTo use it, we need to give some data to pass in.\nThe code below shows a few different ways to do this.\nIn all cases, `pos` is an instance of our struct.\nThe three are equivalent; try uncommenting and running each one:\n\n```rust,editable,no_run\nstruct Position(i32, i32);\n\n// Create a `Position` using tuple syntax.\nlet pos = Position(1, 0);\n\nprint_position(&pos);\n\n// Use the fields of the struct directly to create the same instance.\nlet pos = Position(2, 5);\n\nprint_position(&pos);\n\n// Use `struct` notation with a temporary variable.\nlet x: i32 = 4;\nlet y: i32 = 7;\nlet pos = Position(x + 1, y - 1);\n\nprint_position(&pos);\n```\n\nWe can also create an instance of our struct using `struct` notation to give each field a name.\nThis is very similar to the tuple method shown above.\nThe main difference is that this way we get to use names for the fields when accessing them in code:\n\n```rust,editable\nstruct Position(i32, i32); // Note no names here!\n\nlet pos = Position(10, 24);\n\n// Use struct access notation.\nprintln!(\"The position is at ({}, {})\", pos.0, pos.1);\n```\n\n## Fields and Methods\n\nBecause `struct`s are a way to group related data together into one nameable thing, they have two distinct features: fields and methods.\n\n# Fields\n\nFields are the parts of the struct that make up the data it represents.\nThe above definition of `Position` is made up of two fields, an `x` field and a `y` field.\nIn code, we refer to these using dot notation:\n\n```rust,editable\nstruct Position(i32, i32);\n\nlet pos = Position(10, 24);\n\n// Access the data in `pos`.\nprintln!(\"The position is at ({}, {})\", pos.0, pos.1);\n```\n\nYou may have noticed that each field has an index associated with it.\nThis number tells us which field we're accessing: the first field (the one before the comma) will always be 0 and the second (and all subsequent fields) will increment by 1.\nIn this case, `pos.0` accesses the `x` field of `pos`.\nIt's usually clear from context which field is being accessed, so we often omit these indices:\n\n```rust,editable\nstruct Position(i32, i32);\n\nlet pos = Position(10, 24);\n\n// Access the data in `pos` using field names.\nprintln!(\"The position is at ({}, {})\", pos.x, pos.y);\n```\n\nThis feature of structs comes from a language feature called **pattern matching**, and we'll use it later when discussing methods.\nFor now, all you need to know about pattern matching is that it can be used with `struct`s as shown above (and also in [this chapter](../ch05-2-everything-is-an-expression/index.html) where we learned how to use patterns for destructuring).\n\n# Methods\n\nMethods are functions associated with a particular type.\nWe've been using methods all along!\nFor example, the `cargo` tool provides a command named `new`, which looks something like this:\n\n```text\n$ cargo new <PROJECT_NAME>\n```\n\n`<PROJECT_NAME>` is an argument to the function called `new`.\nHere's how it might look if we wrote our own program with methods:\n\n```rust,editable,ignore\nstruct Arguments { name: String }\n\nfn new(name: &str) -> Arguments {\n    // ...snip...\n}\n```\n\nTo call a method, we use `method_name(receiver)` syntax.\nThe receiver is the thing that gets passed as the first parameter to the method; in this case it's an instance of `Arguments`.\nNote that we can also name the function parameter something else entirely!\n\n```rust,editable,ignore\nstruct Arguments { name: String }\n\nfn new(name: &str) -> Arguments {\n    // ...snip...\n}\n\n// `a` is not used anywhere in this code.\nlet a = Arguments::new(\"my_project\");\n```\n\nMethods can be used to define functionality that's related to the data of the type they're called on.\nThis way, we can keep related functionality together within the same module.\nFor example, consider our `Position` struct from earlier:\n\n```rust,editable\n#[derive(Debug)]\nstruct Position(i32, i32);\n\n// Create a new method for calculating the distance to another position.\nimpl Position {\n    fn dist(&self, other: &Position) -> u32 {\n        let x_sq = (other.0 - self.0).pow(2);\n        let y_sq = (other.1 - self.1).pow(2);\n        \n        (x_sq + y_sq).sqrt() as u32\n    }\n}\n```\n\nThe `impl` keyword is short for \"implementation\" and says that the following block of code contains methods that are associated with a type, in this case our `Position`.\nThe above method `dist` takes an instance of `self`, another instance of `Position`, and returns a `u32` representing the distance between two positions.\n\nNote: we use `impl` to indicate which types have what methods defined for them.\nThere's also the keyword `trait` that can be used in a similar way to specify what functionality is available for a given type.\nWe won't get into that until later on, though!\n\n### Activities\n\n#### Struct with methods\n\n1. Add a method to your `FloatWithUnits` struct that takes another instance of the same struct and returns an `f64` representing how far apart they are in the units those types use.\n2. Implement a second unit for our struct, something other than meters (maybe inches or feet).\n3. Add methods to your struct so you can convert between different units.\n\n#### Struct with fields and methods\n\n1. Write a function that takes an instance of your `FloatWithUnits` struct and prints out the value and unit.\n2. Modify your struct to use field names instead of indices for accessing its data, then modify the code you wrote in 1 to work with it.\n3. Change any methods so they take a `&self` parameter instead of an argument and change `dist` above to take two arguments instead of one (this will involve changing how we call it as well).","status":200,"tokens":[54,1808],"elapsed":107.641178833,"_type":"aimessage"}]