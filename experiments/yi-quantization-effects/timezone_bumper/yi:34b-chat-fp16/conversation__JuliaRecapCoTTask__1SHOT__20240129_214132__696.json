[{"content":"You are a world-class Julia language programmer and have a very systematic approach to solving problems.\n\nProblem Solving Steps:\n- Recall Julia snippets that will be useful for this Task\n- Solve the Task\n- Double-check that the solution is correct\n\nReminder on Julia Language:\n- Key Syntax: variables `x = 10`, control structures `if-elseif-else`, `isX ? X : Y`, `for`, `while`; functions `function f(x) end`, anonymous `x -> x^2`, arrays `[1, 2, 3]`, slicing `a[1:2]`, tuples `(1, 2)`, namedtuples `(; name=\"Julia\", )`, dictionary `Dict(\"key\" => value)`, `$` for string interpolation. \n- Prefer Julia standard libraries, avoid new packages unless explicitly requested. \n- Use general type annotations like `Number` or `AbstractString` to not be too restrictive. Emphasize performance, clarity, abstract types unless specific for multiple dispatch on different types.\n- Reserved names: `begin`, `end`, `function`. \n- Distinguished from Python with 1-based indexing, multiple dispatch\n\nIf the user provides any Special Instructions, prioritize them over the above guidelines.\n  ","variables":[],"_type":"systemmessage"},{"content":"# Task\n\nWrite a function `timezone_bumper(dt,bump)` that increases any provided timestamp by `bump::Int` hours (defaults to +3 hours). Make sure it works only for DateTime types and throws an error for Date types.\n\n\n\n# Special Instructions\n\n{{instructions}}\n","variables":["task","instructions"],"_type":"usermessage"},{"content":"If no special instructions are provided, I will proceed with the task assuming the following:\n\n1. The function should add `bump` hours to a `DateTime` object.\n2. If `bump` is not provided, it should default to +3 hours.\n3. The function should work only with `DateTime` objects and throw an error if a `Date` object is passed.\n4. The function should use the standard Julia libraries without importing additional packages unless specified otherwise.\n5. The function should prioritize performance while maintaining clarity in the code.\n6. The function should support multiple dispatch on different types of inputs (DateTime, Date).\n\nHere's the solution based on these assumptions:\n\n```julia\nusing Dates\n\nfunction timezone_bumper(dt::DateTime, bump::Int = 3)\n    if !(isa(bump, Int)) || bump < 0\n        throw(ArgumentError(\"`bump` must be a non-negative integer. Received $bump\"))\n    end\n    return DateTime(Dates.unix2datetime(Dates.unix(dt) + (60 * 60 * bump)))\nend\n\nfunction timezone_bumper(dt::Date)\n    throw(ArgumentError(\"`timezone_bumper` can only be applied to `DateTime` objects, not `Date` objects. Received $dt\"))\nend\n```\n\nThis function uses the standard Julia library for dates and times (`Dates`) and defines two methods: one for `DateTime` with an optional `bump` argument and another for `Date` that throws an error as per the instructions. The `unix2datetime` function is used to convert the Unix timestamp (seconds since 1970-01-01) to a `DateTime`, and then the desired timezone bump is added before converting back to a `DateTime` object.\n\nTo double-check that the solution is correct:\n\n1. Ensure that the function works as expected with both positive and negative `bump` values for `DateTime` objects.\n2. Test that an error is thrown when a `Date` object is passed.\n3. Verify that the function is type-stable by running a benchmark or using the `@code_warntype` macro.\n4. Ensure that the documentation of the function is clear and helpful for users.\n5. Check if there are any edge cases (e.g., handling dates at the end of DST transitions) that need to be addressed.\n\nIf specific special instructions are provided, I will modify the solution accordingly.","status":200,"tokens":[0,570],"elapsed":44.588250293,"_type":"aimessage"}]